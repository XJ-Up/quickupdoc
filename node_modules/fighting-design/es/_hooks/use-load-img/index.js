import { ref as g, onMounted as I, watch as M } from "vue";
import { sizeChange as S, sizeToNum as T } from "../../_utils/utils/index.js";
import { useRun as z } from "../use-run/index.js";
const O = (s, r, u) => {
  const { run: d } = z(), a = g(!0), f = g(!1);
  let m = !1;
  const h = (e, n, t) => {
    e.src = t, a.value = !0, f.value = !0, d(r.onLoad, n);
  }, b = (e) => {
    a.value = !1, d(r.onError, e);
  }, i = (e, n) => {
    const t = new Image();
    new Promise((o, l) => {
      t.src = n || r.src, t.addEventListener("load", (c) => {
        o(c);
      }), t.addEventListener("error", (c) => {
        l(c);
      });
    }).then((o) => {
      o && h(e, o, t.src);
    }).catch((o) => {
      if (!m && r.errSrc) {
        i(e, r.errSrc), m = !0;
        return;
      }
      b(o);
    });
  }, E = (e) => {
    const n = new IntersectionObserver(
      /**
       * @param { Array } arr 观察的元素数组
       */
      (t) => {
        t[0].isIntersecting && (i(e), n.unobserve(e));
      },
      { rootMargin: S(r.rootMargin) }
    );
    return n;
  }, L = (e) => {
    const n = () => {
      const t = window.innerHeight || document.documentElement.clientHeight, o = document.documentElement.scrollTop || document.body.scrollTop, l = e.offsetParent.offsetTop, c = t + o - l;
      Math.abs(c) < Math.abs(T(r.rootMargin)) && (i(e), window && window.removeEventListener("scroll", n));
    };
    window && window.addEventListener("scroll", n);
  }, v = () => {
    if (s.value) {
      if (r.lazy) {
        IntersectionObserver ? E(s.value).observe(s.value) : L(s.value);
        return;
      }
      i(s.value);
    }
  }, w = () => {
    if (u) {
      if (u())
        v();
      else
        return;
      return;
    }
    v();
  };
  return I(() => {
    w();
  }), M(
    () => r.src,
    () => {
      w();
    }
  ), { isSuccess: a, isShowNode: f };
};
export {
  O as useLoadImg
};
